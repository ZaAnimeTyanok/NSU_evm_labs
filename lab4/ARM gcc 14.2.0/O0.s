pi:                                         // начало функции pi
        push    {r4, r5, r7, lr}            // cохранение регистров r4, r5, r7 и адреса возврата в стек
        vpush.64        {d8}                // cохранение векторного регистра d8 в стек
        sub     sp, sp, #32                 // выделение 32 байт в стеке
        add     r7, sp, #0                  // установка указателя r7 на вершину стека
        strd    r0, [r7]                    // сохранение значения r0 (первый аргумент) по адресу r7
        mov     r3, #-1                     // инициализация r3 значением -1
        str     r3, [r7, #28]               // сохранение r3 по адресу r7 + 28
        mov     r2, #0                      // инициализация r2 значением 0
        mov     r3, #0                      // инициализация r3 значением 0
        movt    r3, 16368                   // установка верхней части r3 (младшие биты остаются нулями)
        strd    r2, [r7, #16]               // сохранение значения r2 по адресу r7 + 16
        mov     r2, #1                      // установка r2 равным 1
        mov     r3, #0                      // сброс r3
        strd    r2, [r7, #8]                // сохранение значения r2 по адресу r7 + 8
        b       .L2                         // переход к метке .L2
.L3:                                        // начало цикла
        ldr     r3, [r7, #28]               // загрузка значения из памяти по адресу r7 + 28 в r3
        vmov    s15, r3                     // перемещение значения r3 в s15 (векторный регистр)
        vcvt.f64.s32    d8, s15             // преобразование значения s15 в двойную точность и сохранение в d8
        ldrd    r0, [r7, #8]                // загрузка значения из памяти по адресу r7 + 8 в r0 и r1
        bl      __aeabi_l2d                 // вызов функции преобразования целого числа в двойную точность
        vmov    d7, r0, r1                  // перемещение результата в d7
        vadd.f64        d7, d7, d7          // удвоение значения в d7
        vmov.f64        d6, #1.0e+0         // установка d6 равным 1.0
        vadd.f64        d6, d7, d6          // сложение d6 и d7
        vdiv.f64        d7, d8, d6          // деление d8 на d6 и сохранение результата в d7
        vldr.64 d6, [r7, #16]               // Загрузка значения из памяти по адресу r7 + 16 в d6
        vadd.f64        d7, d6, d7          // сложение d6 и d7
        vstr.64 d7, [r7, #16]               // сохранение результата обратно по адресу r7 + 16
        ldr     r3, [r7, #28]               // загрузка значения из памяти по адресу r7 + 28 в r3
        rsbs    r3, r3, #0                  // вычисление -r3 (обратное значение)
        str     r3, [r7, #28]               // сохранение нового значения r3 по адресу r7 + 28
        ldrd    r2, [r7, #8]                // загрузка значения из памяти по адресу r7 + 8 в r2 и r3
        adds    r4, r2, #1                  // увеличение значения в r2 на 1 и сохранение в r4
        adc     r5, r3, #0                  // учет возможного переноса при сложении с r3 и сохранение в r5
        strd    r4, [r7, #8]                // сохранение нового значения по адресу r7 + 8
.L2:                                        // проверка условия цикла
        ldrd    r0, [r7, #8]                // загрузка значения из памяти по адресу r7 + 8 в r0 и r1
        ldrd    r2, [r7]                    // загрузка значения из памяти по адресу r7 в r2 и другой регистр
        cmp     r0, r2                      // сравнение значений в r0 и r2
        sbcs    r3, r1, r3                  // учет возможного переноса при сравнении
        blt     .L3                         // если меньше - переход к метке .L3
        vldr.64 d7, [r7, #16]               // загрузка значения из памяти по адресу r7 + 16 в d7
        vmov.f64        d6, #4.0e+0         // установка d6 равным 4.0
        vmul.f64        d7, d7, d6          // умножение d7 на d6
        vstr.64 d7, [r7, #16]               // Сохранение результата обратно по адресу r7 + 16
        ldrd    r2, [r7, #16]               // загрузка значения из памяти по адресу r7 + 16 в r2 и другой регистр
        vmov    d7, r2, r3                  // перемещение результата в d7
        vmov.f64        d0, d7              // перемещение результата в регистр возвращаемого значения
        adds    r7, r7, #32                 // освобождение пространства в стеке (32 байта)
 	mov     sp, r7                      // обновление указателя стека
        vldm    sp!, {d8}                   // восстановление векторного регистра d8 из стека
        pop     {r4, r5, r7, pc}            // восстановление регистров и возврат из функции
.LC0:                                       // строка формата для scanf (long long)
        .ascii  "%lld000"
.LC1:                                       // Строка формата для printf (long gouble)
        .ascii  "%Lf000"          
main:                                       // начало функции main
        push    {r7, lr}                    // сохранение регистров на стек
        sub     sp, sp, #8                  // выделяем 8 байт в стеке
        add     r7, sp, #0                  // установка указателя на стек в регистр r7
        mov     r3, r7                      // копирование адреса стека в регистр r3
        mov     r1, r3                      // копирование адреса стека в регистр для scanf
        movw    r0, #:lower16:.LC0          // загрузка адреса строки формата для scanf
        movt    r0, #:upper16:.LC0  
        bl      __isoc99_scanf              // вызов функции scanf для чтения входных данных
        ldrd    r2, [r7]                    // загрузка считанного значения из стека в регистр
        mov     r0, r2                      // перемещение считанного значения в регистр для передачи в pi()
        mov     r1, r3                      // передача адреса стека как второго аргумента
        bl      pi                          // вызов функции pi
        vmov    r2, r3, d0                  // перемещение результата pi из d0 в регистры для printf
        movw    r0, #:lower16:.LC1          // загрузка адреса строки формата для printf
        movt    r0, #:upper16:.LC1  
        bl      printf                      // вызов функции printf для вывода результата
        movs    r3, #0                      // установка статуса возврата равным 0
        mov     r0, r3                      // подготовка к возврату статуса
        adds    r7, r7, #8                  // освобождение пространства в стеке (8 байт)
        mov     sp, r7                      // обновление указателя стека
        pop     {r7, pc}                    // восстановление регистров и возврат из функции main
