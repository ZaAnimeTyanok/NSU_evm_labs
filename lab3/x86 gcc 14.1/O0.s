	.file	"main.c"	# имя исходного файла
	.text			# начало секции кода
	.def	_scanf;	.scl	3;	.type	32;	.endef		# определение функции scanf, директива .scl определяет тип символа, по сути определяет тип функции по области видимости, .type указывает на тип символа, в нашем случае .type 32 говорит о том, что это функция.   
_scanf:				# реализация функции
	pushl	%ebp		# push помещает указатель в стек, тут мы помещаем регистр EBP на  стек, "l" на конце комманды означает, что мы работаем с 32 битными значениями
	movl	%esp, %ebp 	# mov x, y копирует x в y, тут мы копируем ESP в EBP, по сути устанавливая новый указатель стека
	pushl	%ebx		# сохраняем EBX на стеке
	subl	$36, %esp	# sub x, y вычитает x из y, по сути мы так выделяем 36 байт (используем для этого вычитание, поскольку данные в стеки хранятся в порядке уменьшения значения адреса) на указателе из ESP, который является базовым для стека. 
	leal	12(%ebp), %eax 	# lea x, y помещает адресс x в y
	movl	%eax, -16(%ebp)	# адресс операнда формируется синтаксической конструкцией "смещение(база, индекс, множитель)", вычисленный адрес будет равен база + индекс × множитель + смещение, по умолчанию смещение и индекс = 0, множитель = 1
	movl	-16(%ebp), %ebx	# с учетом комментария выше, -16(%ebp) означает, что мы берем адресс EBP со смещением -16
	movl	$0, (%esp) 	# дальше мы будем записывать переменные из входного потока, для этого устанавливаем первый аргумент для scanf 
	movl	__imp____acrt_iob_func, %eax # тут мы загружаем адрес функции для работы с потоками в EAX
	call	*%eax 		# вызываем фунцию из EAX, которая возвращает указатель на stdin (поток ввода)
	movl	%ebx, 8(%esp)	# устанавливаем второй аргумент (адрес переменной для ввода)
	movl	8(%ebp), %edx 	# загружаем третий аргумент (формат ввода)
	movl	%edx, 4(%esp) 	# устанавливаем третий аргумент для scanf
	movl	%eax, (%esp)	# устанавливаем указатель на stdin как первый аргумент для scanf
	call	___mingw_vfscanf # вызываем функцию для считывания данных
	movl	%eax, -12(%ebp)	# сохраняем количество считанных элементов
	movl	-12(%ebp), %eax # загружаем результат (количество считанных элементов) в EAX
	movl	-4(%ebp), %ebx 	# загружаем значение из локальной переменной в EBX
	leave			# выходим из процедуры, восстанавливаем старое значение базового указателя стека
	ret			# возвращаемся из функции 
	.def	_printf;	.scl	3;	.type	32;	.endef	#определяем фунцкию printf
_printf:			# реализуем printf, многое аналогично scanf, только тут мы работаем с потоком вывода
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$36, %esp
	leal	12(%ebp), %eax
	movl	%eax, -16(%ebp)
	movl	-16(%ebp), %ebx
	movl	$1, (%esp)
	movl	__imp____acrt_iob_func, %eax
	call	*%eax
	movl	%ebx, 8(%esp)
	movl	8(%ebp), %edx
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	call	___mingw_vfprintf
	movl	%eax, -12(%ebp)
	movl	-12(%ebp), %eax
	movl	-4(%ebp), %ebx
	leave
	ret	
	.globl	_pi		# .globl указывает, что подпрограмма является глобальной и может быть использоваться вне этого файла
	.def	_pi;	.scl	2;	.type	32;	.endef # определяем функцию pi
_pi:				# реализация функции
	pushl	%ebp 
	movl	%esp, %ebp
	subl	$40, %esp 	# выделяем 40 байт на стеке для локальных переменных
	movl	8(%ebp), %eax	# загружаем первый аргумент (n) в EAX
	movl	12(%ebp), %edx	# загружаем второй аргумент (значение) в EDX
	movl %eax, -40(%ebp)    # сохраняем n в локальной переменной
 	movl %edx, -36(%ebp)    # сохраняем значение в локальной переменной
 	movl $-1, -4(%ebp)      # инициализируем счетчик цикла (i = -1)
 	fld1                    # комманды fld отвечают за загрузку вещественных, fld1 загружает константу 1.0 в стек FPU, который хранит значения с плавающей запятой
 	fstpt -16(%ebp)         # fstp записывает вещесивенное число, тут мы сохраняем полученный 1.0 в локальной переменной (результат)
 	movl $1, -24(%ebp)      # инициализируем счетчик итераций (i = 1)
 	movl $0, -20(%ebp)      # инициализируем дополнительный счетчик (carry = 0)
	jmp L6                  # jmp совершает безусловный переход, тут мы переходим к метке L6 (условию цикла)
L7:                         	# метка начала тела цикла
 	fildl -4(%ebp)          # загружаем i в стек FPU как целое число
 	fildq -24(%ebp)         # загружаем текущее значение итерации как вещественное число
 	fld %st(0)              # копируем верхний элемент стека FPU (значение)
 	faddp %st, %st(1)       # складываем два верхних элемента стека FPU и удаляем их 
 	fld1                    # загружаем 1.0 в стек FPU снова
 	faddp %st, %st(1)       # складываем с предыдущим результатом 
 	fdivrp %st, %st(1)      # делим результат на верхний элемент и удаляем его 
 	fldt -16(%ebp)          # загружаем текущий результат из локальной переменной 
 	faddp %st, %st(1)       # складываем с предыдущим результатом 
 	fstpt -16(%ebp)         # cохраняем новый результат обратно в локальную переменную 
 	negl -4(%ebp)           # инвертируем счетчик i (i = -i)
 	addl $1, -24(%ebp)      # увеличиваем счетчик итераций i на 1 
 	adcl $0, -20(%ebp)      # обновляем carry (перенос)
L6:                         	# метка условия цикла 
 	movl -24(%ebp), %eax    # загружаем текущее значение итераций в EAX 
 	movl -20(%ebp), %edx    # загружаем carry в EDX 
 	cmpl -40(%ebp), %eax    # сравниваем i с n 
 	movl %edx, %eax         # переносим carry в EAX 
 	sbbl -36(%ebp), %eax    # вычитаем значение из EAX с учетом переноса 
 	jl L7                   # если i < n, продолжаем цикл
 	fldt -16(%ebp)          # загружаем окончательный результат из локальной переменной 
 	fldt LC1                # загружаем константу LC1 из секции данных 
 	fmulp %st, %st(1)       # умножаем два верхних элемента стека и удаляем один из них 
 	fstpt -16(%ebp)         # сохраняем окончательный результат обратно в локальную переменную 
 	fldt -16(%ebp)          # загружаем результат для возврата 
 	leave                    
 	ret
	.section .rdata,"dr" 	# начало секции данных read-only
LC3:				# метка с форматом строки для scanf (для long long)
	.ascii "%lld\0"		# .ascii — директива для размещения в памяти строковых литералов, не добавляющая нулевой байт
LC4:				# метка с форматом строки для printf (для long double)
	.ascii "%Lf\0"
	.text
	.globl	_main
	.def	_main;	.scl	2;	.type	32;	.endef
_main:				# реализация мейна 
	pushl	%ebp
	movl	%esp, %ebp
	andl	$-16, %esp	# and выполняет операцию побитовой конъюнкции, тут используется для выравнивания стека по границе 16 байт 
	subl	$32, %esp
	call	___main		# вызываем функцию инициализации программы 
	leal	24(%esp), %eax	# получаем адрес переменной для ввода 
	movl	%eax, 4(%esp)	# устанавливаем адрес переменной как второй аргумент 
	movl	$LC3, (%esp)	# устанавливаем формат строки как первый аргумент для scanf 
	call	_scanf		# вызываем scanf
	movl	24(%esp), %eax	# загружаем считанное значение в EAX 
	movl	28(%esp), %edx  # загружаем следующее значение в EDX, по сути мы разделили 64-битный long long на два 32-битных регистра 
	movl	%eax, (%esp)	# передаем полученные значения как аргументы для функции pi
	movl	%edx, 4(%esp)
	call	_pi		# вызываем функцию
	fstpt	4(%esp)		# cохраняем результат работы функции _i по адресу 4(ESP)
	movl	$LC4, (%esp)	# устанавливаем формат строки как первый аргумент для printf 
	call	_printf		# вызываем printf
	movl	$0, %eax	# возвращаем код завершения 0 
	leave
	ret
	.section .rdata,"dr"
	.align 16
LC1:				# метка с инициализацией констант
	.long	0
	.long	-2147483648
	.long	16385
	.def	___main;	.scl	2;	.type	32;	.endef
	.ident	"GCC: (GNU) 14.1.0"
	.def	___mingw_vfscanf;	.scl	2;	.type	32;	.endef
	.def	___mingw_vfprintf;	.scl	2;	.type	32;	.endef
